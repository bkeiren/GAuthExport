'''
This Python script can parse QR codes generated by Google Authenticator's "Export Accounts" feature and
extract the accounts and their secrets for easy transference to other authenticator apps.
'''

import argparse
import pathlib
from urllib.parse import urlparse
from urllib.parse import parse_qs
from urllib.parse import urlencode
from urllib.parse import urlunsplit
from urllib.parse import unquote
import base64
import io
import qrcode               # For QR code generating
from pyzbar import pyzbar   # For QR code reading
import cv2                  # For image loading and video feed processing



class BytesStream(io.BytesIO):
    def __init__(self, initial_bytes):
        super().__init__(initial_bytes)

    def peek(self, size):
        bytes = self.read(size)
        self.seek(self.tell() - size)
        return bytes



def read_string(bytes_io):
    '''
    Read a string from bytes where the first byte is expected to indicate the length, with the string contents
    following immediately after.

    :param bytes_io: Instance of BytesStream from which to read
    :return: The read string
    '''
    if not isinstance(bytes_io, BytesStream):
        raise ValueError("Expected BytesStream instance")

    # Read string length
    length = ord(bytes_io.read(1))

    # Read string
    return bytes_io.read(length).decode('utf-8')



def read_expect_byte(bytes_io, expected_byte, fatal=False):
    '''
    Read a single byte from bytes_io, and check whether it matches the expected byte value.
    If the byte value does not match, a warning is printed

    :param bytes_io: Instance of BytesStream from which to read
    :param expected_byte: The byte value that is expected to be found
    :param fatal: If true, a ValueError is raised. Otherwise a message is printed
    :return: True if the expected value matches, otherwise False
    '''
    if not isinstance(bytes_io, BytesStream):
        raise ValueError("Expected BytesStream instance")

    found_byte = bytes_io.read(1)
    if found_byte != expected_byte:
        message = "Expected to find byte value '{}' at position {}, but found '{}'".format(str(expected_byte), bytes_io.tell()-1, str(found_byte))
        if fatal:
            raise ValueError(message)
        else:
            print(message)
        return False

    return True



def extract_one_account(bytes_io):
    '''
    Extract one account out of bytes_io. Expects the account data to start at the current position in bytes_io.

    :param bytes_io: Instance of BytesStream from which to read
    :return: None, if none account data could be parsed, or else a dictionary in the form of:
             {'label': str, 'issuer': str, 'secret' : str}
              'label' is the user-configured name with which the item is shown in GA (i.e.: user@email.com)
             'issuer' is the service with which the item is linked (i.e.: Dropbox, Google, etc.)
             'secret' is a string representation of the base32 encoded secret that is needed to generate codes
    '''
    if not isinstance(bytes_io, BytesStream):
        raise ValueError("Expected BytesStream instance")

    # Read 1 byte that contains the length of the entire account entry
    account_length = ord(bytes_io.read(1))
    pos_after_account_length = bytes_io.tell()

    # Read 1 more byte that seems to always be a newline character
    read_expect_byte(bytes_io, b'\n')

    # Read 1 byte that contains the length of the secret
    secret_length = ord(bytes_io.read(1))

    # Read <secret_length> number of bytes for the secret
    secret_bytes = bytearray(bytes_io.read(secret_length))

    secret = base64.b32encode(secret_bytes).decode('utf-8')

    label = ""
    issuer = ""

    # Read the label and issuer; in a loop to accomodate a potential case
    # where the two are in a different order.
    # Additionally, it's also possible for only one of the two to be present.
    # In that case we should rewind the IO stream and skip the value entirely.
    for i in range(2):
        # Read 1 marker byte
        marker = bytes_io.read(1)

        if marker == b'\x12':  # Label marker value
            label = read_string(bytes_io)
        elif marker == b'\x1A':  # Issuer marker value
            issuer = read_string(bytes_io)
        else:
            # Rewind to the previous position
            bytes_io.seek(bytes_io.tell() - 1)

    # Skip the next 6 bytes. These always seem to be:
    # 20 01 28 01 30 02
    bytes_io.seek(bytes_io.tell() + 6)

    # Verify that we did indeed reach <account_length> number of bytes up to this point
    read_length = bytes_io.tell() - pos_after_account_length
    if read_length != account_length:
        raise ValueError("Account length was parsed as {}, but consumed {} bytes to parse account!".format(account_length, read_length))

    return {"label": label, "issuer": issuer, "secret": secret}



def extract_account_data(base64_ga_payload):
    '''
    Extract accounts data from the base64-encoded payload data that GA generates

    :param base64_ga_payload: Bytes-like objects containing the base64-encoded data that GA generates
    :return: A list where each items is a dictionary in the form: {'label': str, 'issuer': str, 'secret' : str}
             'label' is the user-configured name with which the item is shown in GA (i.e.: user@email.com)
             'issuer' is the service with which the item is linked (i.e.: Dropbox, Google, etc.)
             'secret' is a string representation of the base32 encoded secret that is needed to generate codes
    '''
    payload_bytes = BytesStream(base64.b64decode(base64_ga_payload))
    accounts = list()

    while True:
        # Skip a newline character
        read_expect_byte(payload_bytes, b'\n')

        # Read one account worth of data
        data = extract_one_account(payload_bytes)

        # Log the found data, just so we have some intermediate output visible should things fall over
        print("\t[{}]: {}".format(len(accounts), data))
        accounts.append(data)

        # The following 3 bytes seem to follow after the last account: 10 01 18
        # We use this as our termination condition. There are more bytes after this, but
        # at this time we don't know what they mean so we'll just ignore them. Possibly
        # these contain some checksum to verify the rest of the data's integrity.
        if payload_bytes.peek(3) == b'\x10\x01\x18':
            break

    return accounts



def generate_registration_url(label, secret, issuer=None):
    '''
    Generate the registration URL for an account with a certain label, issuer, and base32-encoded secret.

    :param label: String of the label of the account; may be empty in which case <issuer> must not be empty
    :param issuer: String of the issuer of the account; may be empty
    :param secret: String representation of a base32-encoded secret
    :return: The registration URL in the format:
             otpauth://totp/label?secret=secret&issuer=issuer
    '''
    query_parts = {"secret": secret}

    if issuer:
        query_parts["issuer"] = issuer

    url = urlunsplit(("otpauth", "totp", label, urlencode(query_parts), ""))
    return url



def sanitize_filename(filename):
    '''
    Sanitizes a filename (not a path!) to not include characters that are illegal for filenames (on Windows, mostly).
    Illegal characters are replaced with an underscore (_)

    :param filename: Filename to sanitize
    :return: The sanitized filename
    '''
    sanitized_filename = filename
    illegal_chars = "<>:\/\\|?*"

    for char in illegal_chars:
        sanitized_filename = sanitized_filename.replace(char, "_")

    return sanitized_filename



def main():
    '''
    Main script entrypoint; parses command line arguments to determine script configuration
    '''
    parser = argparse.ArgumentParser(description="Parse QR codes generated by Google Authenticator's 'Export Accounts' feature and extract accounts and secrets")
    parser.add_argument("--image", type=pathlib.Path, nargs="+", help='Path(s) to one or more QR code(s) generated by Google Authenticator')
    parser.add_argument("--text", type=str, nargs="+", help='Text representation of one or more QR code(s) generated by Google Authenticator')
    parser.add_argument("--output_directory", type=pathlib.Path, nargs=1, help='Output directory in which to save generated results')
    args = parser.parse_args()

    text_inputs = []

    # Parse image inputs
    if args.image:
        for i, path in enumerate(args.image):
            print("Ingesting input image [{} / {}]...".format(i+1, len(args.image)), end=" ")

            img = cv2.imread(str(path), 0)

            if img is None:
                raise ValueError("Couldn't open image '{}'".format(str(path)))

            codes = pyzbar.decode(img)
            if not codes:
                # Experience has shown that pyzbar sometimes fails to parse QR codes from images
                # with a resolution that's too high. To cover that case, we can try to resize the image once
                # to retry parsing.
                if img.shape[0] > 1500 or img.shape[1] > 1500:
                    resized_img = cv2.resize(img, (1500, 1500))
                    codes = pyzbar.decode(resized_img)

            if not codes:
                print(" => Failed to detect any QR code in image '{}'. Perhaps the dimensions are too large?".format(str(path)))
            else:
                print(" => Identified {} scannable code(s) in '{}'".format(len(codes), str(path)))
                for code in codes:
                    text_inputs.append(code.data.decode("utf-8"))

    # Grab text inputs
    if args.text:
        for i, text in enumerate(args.text):
            print("Ingesting input text parameter [{} / {}]...".format(i+1, len(args.text)))
            text_inputs.append(text)

    # Parse all inputs to extract account information
    extracted_accounts = []
    for i, text_input in enumerate(text_inputs):
        print("Extracting accounts from input [{} / {}]...".format(i+1, len(text_inputs)))

        # Parse the URL and extract the query string
        url_parse_result = urlparse(text_input)
        query_parts = parse_qs(url_parse_result.query)

        if 'data' not in query_parts:
            raise ValueError("Input URL from GA QR code is missing the expected 'data' parameter")

        # Unquote the URL input, since GA encodes it
        base64_payload = unquote(query_parts['data'][0])

        # Extract all account information
        extracted_accounts.extend(extract_account_data(base64_payload))

    if not extracted_accounts:
        print("No account data was parsed for some reason")
        return

    # Determine output file base path
    output_directory = ""
    if args.output_directory:
        output_directory = args.output_directory[0]

        # If the requested directory is relative, prepend the current directory to make it absolute
        if not output_directory.is_absolute():
            output_directory = pathlib.Path(__file__).parent / output_directory

        # Make sure the directory tree exists up to and including the desired output directory
        output_directory.mkdir(parents=True, exist_ok=True)

    # Generate URLs and render QR codes for each account
    for i, account in enumerate(extracted_accounts):
        print("Generating output for account [{} / {}]...".format(i+1, len(extracted_accounts)), end=" ")

        label = account['label']
        secret = account['secret']
        issuer = account.get('issuer', None)

        # Generate URL
        registration_url = generate_registration_url(label=label, secret=secret, issuer=issuer)

        # Generate QR code
        qr_data = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_H,
            box_size=10,
            border=4,
        )
        qr_data.add_data(registration_url)
        qr_data.make()
        qr_image = qr_data.make_image()

        # Format image file name
        image_name = "GAuthExport_{}_{}".format(label, secret)
        if issuer:
            image_name += "_{}".format(issuer)

        # Format image file path
        image_path = pathlib.PurePath(output_directory, sanitize_filename(image_name) + ".png")

        # Save QR code image
        qr_image.save(str(image_path))
        print("=> " + str(image_path))



if __name__ == "__main__":
    main()